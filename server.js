// Generated by CoffeeScript 1.6.2
(function() {
  var RedisStore, app, client, cluster, clustered, config, conversations, http, i, io, master, max, pub, redis, server, socketio_settings, sub;

  config = require('../../config/config.js');

  max = require('./max');

  http = require("http");

  clustered = config.instances > 1;

  master = true;

  if (clustered) {
    RedisStore = require("socket.io/lib/stores/redis");
    redis = require("socket.io/node_modules/redis");
    pub = redis.createClient(config.redisport, config.redishost);
    sub = redis.createClient(config.redisport, config.redishost);
    client = redis.createClient(config.redisport, config.redishost);
    cluster = require("cluster");
    master = cluster.isMaster;
    if (master) {
      i = 0;
      while (i < config.instances) {
        cluster.fork();
        i++;
      }
      cluster.on('fork', function(worker) {
        return console.log('forked worker ' + worker.process.pid);
      });
      cluster.on("listening", function(worker, address) {
        return console.log("worker " + worker.process.pid + " is now connected to " + address.address + ":" + address.port);
      });
      cluster.on("exit", function(worker, code, signal) {
        return console.log("worker " + worker.process.pid + " died");
      });
    }
  }

  if (!master || config.instances === 1) {
    console.log('here');
    app = require("express")();
    server = require("http").createServer(app);
    socketio_settings = {
      log: config.debug_socketio
    };
    io = require("socket.io").listen(server, socketio_settings);
    console.log("Socketio Started");
    if (clustered) {
      io.set("store", new RedisStore({
        redisPub: pub,
        redisSub: sub,
        redisClient: client
      }));
    }
    server.listen(config.port);
    app.get("/", function(req, res) {
      return res.sendfile(__dirname + '/index.html');
    });
    conversations = io.of(config.namespace).on("connection", function(socket) {
      socket.on("join", function(data) {
        socket._max_username = data.username;
        return max.User.find({
          username: data.username
        }, function(err, doc) {
          var cid, cids, conversation, rooms, _i, _len;

          cids = (function() {
            var _i, _len, _ref, _results;

            _ref = doc[0].talkingIn.items;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              conversation = _ref[_i];
              _results.push(conversation.id);
            }
            return _results;
          })();
          socket.emit("listening", {
            conversations: cids
          });
          for (_i = 0, _len = cids.length; _i < _len; _i++) {
            cid = cids[_i];
            socket.join(cid);
          }
          rooms = conversations.manager.rooms;
          socket.emit('people', {
            rooms: rooms,
            pid: process.pid
          });
          return socket.broadcast.to(cid).emit('joined', {
            username: data.username,
            conversation: cid
          });
        });
      });
      socket.on("talk", function(data) {
        return socket.broadcast.to(data.conversation).emit('update', {
          conversation: data.conversation,
          username: socket._max_username,
          timestamp: data.timestamp
        });
      });
      socket.on("ask", function(cid) {
        var rooms;

        rooms = conversations.manager.rooms;
        return socket.emit('people', {
          rooms: rooms,
          pid: process.pid
        });
      });
      return socket.on("disconnect", function() {
        return console.log("Disconnected" + socket._max_username);
      });
    });
  }

}).call(this);
