// Generated by CoffeeScript 1.6.2
(function() {
  var RedisStore, app, client, cluster, config, conversations, http, i, io, max, pub, redis, server, sub;

  config = require('../../config/config.js');

  max = require('./max');

  http = require("http");

  if (config.instances > 1) {
    RedisStore = require("socket.io/lib/stores/redis");
    redis = require("socket.io/node_modules/redis");
    pub = redis.createClient(config.redisport, config.redishost);
    sub = redis.createClient(config.redisport, config.redishost);
    client = redis.createClient(config.redisport, config.redishost);
    cluster = require("cluster");
    if (cluster.isMaster) {
      i = 0;
      while (i < config.instances) {
        cluster.fork();
        i++;
      }
      cluster.on('fork', function(worker) {
        return console.log('forked worker ' + worker.process.pid);
      });
      cluster.on("listening", function(worker, address) {
        return console.log("worker " + worker.process.pid + " is now connected to " + address.address + ":" + address.port);
      });
      cluster.on("exit", function(worker, code, signal) {
        return console.log("worker " + worker.process.pid + " died");
      });
    } else {
      app = require("express")();
      server = require("http").createServer(app);
      io = require("socket.io").listen(server);
      io.set("store", new RedisStore({
        redisPub: pub,
        redisSub: sub,
        redisClient: client
      }));
      server.listen(6777);
      app.get("/", function(req, res) {
        return res.sendfile(__dirname + '/index.html');
      });
      io.sockets.on("connection", function(socket) {
        return console.log('socket call handled by worker with pid ' + process.pid);
      });
      conversations = io.of(config.namespace).on("connection", function(socket) {
        console.log('socket call handled by worker with pid ' + process.pid);
        socket.on("join", function(data) {
          socket._max_username = data.username;
          return max.User.find({
            username: data.username
          }, function(err, doc) {
            var cid, cids, conversation, _i, _len;

            cids = (function() {
              var _i, _len, _ref, _results;

              _ref = doc[0].talkingIn.items;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                conversation = _ref[_i];
                _results.push(conversation.id);
              }
              return _results;
            })();
            socket.emit("listening", {
              conversations: cids
            });
            for (_i = 0, _len = cids.length; _i < _len; _i++) {
              cid = cids[_i];
              socket.join(cid);
            }
            conversations["in"](cid).emit('people', {
              inroom: conversations.manager.rooms[conversations.name + '/' + cid].length
            });
            return socket.broadcast.to(cid).emit('joined', {
              username: data.username,
              conversation: cid
            });
          });
        });
        return socket.on("message", function(data) {
          return socket.broadcast.to(data.conversation).emit('update', {
            username: socket._max_username,
            timestamp: data.timestamp
          });
        });
      });
    }
  }

}).call(this);
